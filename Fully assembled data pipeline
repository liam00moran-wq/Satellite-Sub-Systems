import os
import cv2
import csv
import random
import numpy as np
from math import tan, radians



#input image 
input_image_path = "./Lough.jpg"

#output folder
output_folder = r"C:\Users\liam0\Documents\Masters\Sat Sub Sys\bit reduced\1 bit"
csv_path = os.path.join(output_folder, "metadata.csv")


##### CHANGE THESE BASED ON WHAT OUTPUT YOU WANT AND WHAT IMAGE IS USED



#ground coverage of image (m)
ground_image_width_m = 64640
ground_image_height_m = 38857

#camera param
FOV = 60.0

#simulated height above ground e.g. [500,1000,10_000]
camera_heights_m = [10000]

#how many deg for erach rotation 
#yaw count is just 360/step
#use_random_yaw = true for random yaw
use_random_yaw = False
rotation_step_deg = 90
random_yaw_count = 4

#amount you want the images to overlap
overlap_fraction = 0

#output resolution
output_size = (324, 324)

#output bit depth
output_bit_depth = 1   # e.g. 2, 6, 8


#check output folder
os.makedirs(output_folder, exist_ok=True)

#bit depth and rotation funcs

def rotate_full_image(image, angle_deg):
    """Rotate image around center, keeping same size."""
    h, w = image.shape[:2]
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle_deg, 1.0)
    return cv2.warpAffine(
        image,
        M,
        (w, h),
        flags=cv2.INTER_LINEAR,
        borderMode=cv2.BORDER_REFLECT
    )

def quantize_bit_depth(image, bit_depth):
    """Quantize an 8-bit single-channel image to lower bit depth."""
    if bit_depth >= 8:
        return image

    levels = 2 ** bit_depth
    step = 256 // levels

    quantized = (image // step) * step
    return quantized.astype(np.uint8)

#load csv with img names, yaw, size, bit depth, height above ground

csv_file = open(csv_path, "w", newline="")
csv_writer = csv.writer(csv_file)
csv_writer.writerow([
    "image_name",
    "x_m",
    "y_m",
    "height_m",
    "yaw_deg",
    "crop_id",
    "bit_depth",
    "channels"
])

#load img

img = cv2.imread(input_image_path)
if img is None:
    raise FileNotFoundError(f"Could not load image: {input_image_path}")

img_h, img_w = img.shape[:2]

meters_per_pixel_x = ground_image_width_m / img_w
meters_per_pixel_y = ground_image_height_m / img_h

base_name = os.path.splitext(os.path.basename(input_image_path))[0]

#main

for camera_height_m in camera_heights_m:

    footprint_m = 2 * camera_height_m * tan(radians(FOV / 2))
    footprint_px_x = int(footprint_m / meters_per_pixel_x)
    footprint_px_y = int(footprint_m / meters_per_pixel_y)

    stride_px_x = int(footprint_px_x * (1 - overlap_fraction))
    stride_px_y = int(footprint_px_y * (1 - overlap_fraction))

    if footprint_px_x <= 0 or footprint_px_y <= 0:
        continue

    if use_random_yaw:
        yaw_angles = [random.uniform(0, 360) for _ in range(random_yaw_count)]
    else:
        yaw_angles = list(range(0, 360, rotation_step_deg))

    for yaw in yaw_angles:
        rotated = rotate_full_image(img, yaw)
        crop_id = 1

        for y in range(0, img_h - footprint_px_y + 1, stride_px_y):
            for x in range(0, img_w - footprint_px_x + 1, stride_px_x):

                crop = rotated[y:y + footprint_px_y, x:x + footprint_px_x]

                if crop.shape[0] != footprint_px_y or crop.shape[1] != footprint_px_x:
                    continue

                #resize
                crop = cv2.resize(
                    crop,
                    output_size,
                    interpolation=cv2.INTER_LINEAR
                )

                #convert to single channel 
                crop = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)

                #bit-depth reduction
                crop = quantize_bit_depth(crop, output_bit_depth)

                out_name = (
                    f"{base_name}_h{int(camera_height_m)}_yaw{int(yaw)}_{crop_id}.png"
                )

                cv2.imwrite(os.path.join(output_folder, out_name), crop)

                x_center_m = (x + footprint_px_x / 2) * meters_per_pixel_x
                y_center_m = (y + footprint_px_y / 2) * meters_per_pixel_y

                csv_writer.writerow([
                    out_name,
                    round(x_center_m, 2),
                    round(y_center_m, 2),
                    int(camera_height_m),
                    round(yaw, 2),
                    crop_id,
                    output_bit_depth,
                    1
                ])

                crop_id += 1

print(f"Processed {input_image_path}")
csv_file.close()
print(f"DONE: images + metadata.csv generated in {output_folder}")
